<html><head><title>main134</title>
<link rel="stylesheet" type="text/css" href="../pythia.css"/>
<link rel="shortcut icon" href="../pythia32.gif"/></head><body><h2>main134</h2>
Back to <a href="../ExampleKeywords.html" target="page">index.</a>
<pre><code class="language-c++">
// main134.cc is a part of the PYTHIA event generator.
// Copyright (C) 2025 Torbjorn Sjostrand.
// PYTHIA is licenced under the GNU GPL v2 or later, see COPYING for details.
// Please respect the MCnet Guidelines, see GUIDELINES for details.

// Authors:
//            Stefan Prestel

// Contact: Christian Preuss &lt;preuss@uni-wuppertal.de&gt;

// Keywords:
//            <a href="../ExampleKeywords.html#lhe+file">LHE&nbsp;file</a>
//            <a href="../ExampleKeywords.html#hepmc">Hepmc</a>

// This program illustrates how a file with HepMC2 or HepMC3 events
// can be generated by Pythia8 using LHEF input. Input and output files are
// specified on the command line, e.g. like
//     ./main134 -c main134.cmnd -o main134.hepmc &gt; main134.log

#include &quot;Pythia8/Pythia.h&quot;
#include &quot;Pythia8Plugins/InputParser.h&quot;
#ifndef HEPMC2
#include &quot;Pythia8Plugins/HepMC3.h&quot;
#else
#include &quot;Pythia8Plugins/HepMC2.h&quot;
#endif
#include &lt;unistd.h&gt;

using namespace Pythia8;

//==========================================================================

// Example main programm to illustrate merging.

int main( int argc, char* argv[] ) {

  // Set up command line options.
  InputParser ip(&quot;This program illustrates how HepMC files can be written by&quot;
    &quot; Pythia8.&quot;, {&quot;./main133 -c main133.cmnd -o main133.hepmc&quot;});
  ip.require(&quot;c&quot;, &quot;Use this user-written command file.&quot;, {&quot;-cmnd&quot;});
  ip.require(&quot;o&quot;, &quot;Specify HepMC output filename.&quot;, {&quot;-out&quot;});

  // Initialize the parser and exit if necessary.
  InputParser::Status status = ip.init(argc, argv);
  if (status != InputParser::Valid) return status;

  // Confirm that external files will be used for input and output.
  string cmnd(ip.get&lt;string&gt;(&quot;c&quot;)), out(ip.get&lt;string&gt;(&quot;o&quot;));
  cout &lt;&lt; &quot;\n &gt;&gt;&gt; PYTHIA settings will be read from file &apos;&quot; &lt;&lt; cmnd
       &lt;&lt; &quot;&apos; &lt;&lt;&lt; \n &gt;&gt;&gt; HepMC events will be written to file &apos;&quot;
       &lt;&lt; out &lt;&lt; &quot;&apos; &lt;&lt;&lt; \n&quot;;

  // Input parameters.
  Pythia pythia;
  pythia.readFile(cmnd, 0);

  // Interface for conversion from Pythia8::Event to HepMC one.
  // Specify file where HepMC events will be stored.
  Pythia8ToHepMC toHepMC(out);

  // Allow abort of run if many errors.
  int  nAbort  = pythia.mode(&quot;Main:timesAllowErrors&quot;);
  int  iAbort  = 0;
  bool doAbort = false;

  // Read in loop parameters.
  cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; endl;
  cout &lt;&lt; &quot;Start generating events&quot; &lt;&lt; endl;
  long nEvent = pythia.settings.mode(&quot;Main:numberOfEvents&quot;);
  int  nRuns  = pythia.mode(&quot;Main:numberOfSubruns&quot;);
  double sigmaTotal(0.), errorTotal(0.);

  // Loop over subruns with varying number of jets.
  for (int iRuns = 0; iRuns &lt; nRuns; ++iRuns) {
    double sigmaSample = 0., errorSample = 0.;

    // Read in name of LHE file for current subrun and initialize.
    pythia.readFile(cmnd, iRuns);

    // If Pythia fails to initialize, exit with error.
    if (!pythia.init()) return 1;

    // Get the inclusive x-section by summing over all process x-sections.
    double xs = 0.;
    for (int i=0; i &lt; pythia.info.nProcessesLHEF(); ++i)
      xs += pythia.info.sigmaLHEF(i);

    // Start generation loop.
    while( pythia.info.nSelected() &lt; nEvent ) {

      // Generate next event.
      if( !pythia.next() ) {
        if ( pythia.info.atEndOfFile() ) break;
        else if (++iAbort &gt; nAbort) {doAbort = true; break;}
        else continue;
      }

      // Get event weight(s).
      double evtweight = pythia.info.weight();

      // Do not print zero-weight events.
      if ( evtweight == 0. ) continue;

      // Inform HepMC3 about the naming of the weights.
#ifndef HEPMC2
      toHepMC.setWeightNames(pythia.info.weightNameVector());
#endif

      // Work with weighted (LHA strategy=-4) events.
      double normhepmc = 1.;
      if (abs(pythia.info.lhaStrategy()) == 4)
        normhepmc = 1. / double(1e9*nEvent);
      // Work with unweighted events.
      else
        normhepmc = xs / double(1e9*nEvent);

      // Set event weights (optional).
#ifndef HEPMC2
      // hepmcevt.weights().push_back(evtweight*normhepmc);
#endif

      // Fill a new HepMC event.
      toHepMC.fillNextEvent( pythia );

      // Add the weight of the current event to the cross section.
      sigmaTotal  += evtweight*normhepmc;
      sigmaSample += evtweight*normhepmc;
      errorTotal  += pow2(evtweight*normhepmc);
      errorSample += pow2(evtweight*normhepmc);

      // Report cross section to HepMC.
      toHepMC.setXSec( sigmaTotal*1e9, errorTotal*1e9 );

      // Write the HepMC event to file. Done with it.
      toHepMC.writeEvent();

    } // End loop over events to generate.
    if (doAbort) break;

    // Print cross section and errors.
    pythia.stat();
    cout &lt;&lt; endl &lt;&lt; &quot; Contribution of sample &quot; &lt;&lt; iRuns
         &lt;&lt; &quot; to the inclusive cross section : &quot;
         &lt;&lt; scientific &lt;&lt; setprecision(8)
         &lt;&lt; sigmaSample &lt;&lt; &quot;  +-  &quot; &lt;&lt; sqrt(errorSample)  &lt;&lt; endl;
  }

  // Abort warning.
  cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; endl;
  if (doAbort)
    cout &lt;&lt; &quot; Run was not completed owing to too many aborted events&quot; &lt;&lt; endl;
  cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; endl;

  // Done
  return 0;

}
</code></pre></body></html>